{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ckb_sdk_rpc_1 = __importDefault(require(\"@nervosnetwork/ckb-sdk-rpc\"));\nconst ckb_sdk_address_1 = __importDefault(require(\"@nervosnetwork/ckb-sdk-address\"));\nconst utils = __importStar(require(\"@nervosnetwork/ckb-sdk-utils\"));\nclass Core {\n    constructor(nodeUrl) {\n        this.utils = utils;\n        this.config = {\n            systemCellInfo: {\n                codeHash: '',\n                outPoint: {\n                    blockHash: '',\n                    cell: {\n                        txHash: '',\n                        index: '0',\n                    },\n                },\n            },\n        };\n        this.generateAddress = (privateKey, { prefix = utils.AddressPrefix.Testnet, type = utils.AddressType.BinIdx, binIdx = utils.AddressBinIdx.P2PH } = {\n            prefix: utils.AddressPrefix.Testnet,\n            type: utils.AddressType.BinIdx,\n            binIdx: utils.AddressBinIdx.P2PH,\n        }) => new ckb_sdk_address_1.default(privateKey, {\n            prefix,\n            type,\n            binIdx,\n        });\n        this.loadSystemCell = () => __awaiter(this, void 0, void 0, function* () {\n            const block = yield this.rpc.getBlockByNumber('0');\n            if (!block)\n                throw new Error('Cannot load the genesis block');\n            const cellTx = block.transactions[0];\n            if (!cellTx)\n                throw new Error('Cannot load the transaction which has the system cell');\n            const cell = cellTx.outputs[1];\n            if (!cell)\n                throw new Error('Cannot load the system cell');\n            const s = this.utils.blake2b(32, null, null, this.utils.PERSONAL);\n            s.update(this.utils.hexToBytes(cell.data.replace(/^0x/, '')));\n            const codeHash = s.digest('hex');\n            const outPoint = {\n                blockHash: block.header.hash.replace(/^0x/, ''),\n                cell: {\n                    txHash: cellTx.hash.replace(/^0x/, ''),\n                    index: '1',\n                },\n            };\n            this.config.systemCellInfo = {\n                codeHash,\n                outPoint,\n            };\n            return this.config.systemCellInfo;\n        });\n        this.signWitnesses = (key) => ({ transactionHash, witnesses = [], }) => {\n            if (!key)\n                throw new Error('Private key or address object is required');\n            if (!transactionHash)\n                throw new Error('Transaction hash is required');\n            const addrObj = typeof key === 'string' ? this.generateAddress(key) : key;\n            const signedWitnesses = witnesses.map(witness => {\n                const oldData = witness.data || [];\n                const s = this.utils.blake2b(32, null, null, this.utils.PERSONAL);\n                s.update(this.utils.hexToBytes(transactionHash.replace(/^0x/, '')));\n                oldData.forEach(datum => {\n                    s.update(this.utils.hexToBytes(datum));\n                });\n                const message = s.digest('hex');\n                const data = [`0x${addrObj.signRecoverable(message)}`, ...oldData];\n                return {\n                    data,\n                };\n            });\n            return signedWitnesses;\n        };\n        this.signTransaction = (key) => (transaction) => __awaiter(this, void 0, void 0, function* () {\n            if (!key)\n                throw new Error('Private key or address object is required');\n            if (!transaction)\n                throw new Error('Transaction is required');\n            if (!transaction.witnesses)\n                throw new Error('Witnesses is required');\n            if (transaction.witnesses.length < transaction.inputs.length)\n                throw new Error('Invalid count of witnesses');\n            const transactionHash = yield this.rpc.computeTransactionHash(transaction);\n            const signedWitnesses = yield this.signWitnesses(key)({\n                transactionHash,\n                witnesses: transaction.witnesses,\n            });\n            return Object.assign({}, transaction, { witnesses: signedWitnesses });\n        });\n        this._node = {\n            url: nodeUrl,\n        };\n        this.rpc = new ckb_sdk_rpc_1.default(nodeUrl);\n        const computeTransactionHashMethod = {\n            name: 'computeTransactionHash',\n            method: '_compute_transaction_hash',\n            paramsFormatters: [this.rpc.paramsFormatter.toRawTransaction],\n        };\n        this.rpc.addMethod(computeTransactionHashMethod);\n    }\n    setNode(node) {\n        if (typeof node === 'string') {\n            this._node.url = node;\n        }\n        else {\n            this._node = node;\n        }\n        this.rpc.setNode(this._node);\n        return this._node;\n    }\n    get node() {\n        return this._node;\n    }\n}\nexports.default = Core;\n//# sourceMappingURL=index.js.map"]}