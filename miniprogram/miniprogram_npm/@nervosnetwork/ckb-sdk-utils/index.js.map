{"version":3,"sources":["index.js","crypto\\index.js","crypto\\bech32.js","crypto\\blake160.js","address\\index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA,AFMA;AIXA,AFMA;AELA,AFMA;AELA,AFMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util = __importStar(require(\"util\"));\nconst crypto_1 = __importDefault(require(\"./crypto\"));\n__export(require(\"./address\"));\nexports.blake2b = crypto_1.default.blake2b, exports.bech32 = crypto_1.default.bech32, exports.blake160 = crypto_1.default.blake160;\nconst textEncoder = new (typeof TextEncoder !== 'undefined' ? TextEncoder : util.TextEncoder)();\nconst textDecoder = new (typeof TextDecoder !== 'undefined' ? TextDecoder : util.TextDecoder)();\nexports.PERSONAL = textEncoder.encode('ckb-default-hash');\nexports.hexToBytes = (rawhex) => {\n    let hex = rawhex.toString(16);\n    hex = hex.replace(/^0x/i, '');\n    hex = hex.length % 2 ? `0${hex}` : hex;\n    const bytes = [];\n    for (let c = 0; c < hex.length; c += 2) {\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n    }\n    return new Uint8Array(bytes);\n};\nexports.bytesToHex = (bytes) => {\n    const hex = [];\n    for (let i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xf).toString(16));\n    }\n    return hex.join('');\n};\nexports.bytesToUtf8 = (bytes) => textDecoder.decode(bytes);\nexports.hexToUtf8 = (hex) => exports.bytesToUtf8(exports.hexToBytes(hex));\nexports.utf8ToBytes = (str) => textEncoder.encode(str);\nexports.utf8ToHex = (str) => exports.bytesToHex(exports.utf8ToBytes(str));\nexports.lockScriptToHash = ({ codeHash, args }) => {\n    const s = exports.blake2b(32, null, null, exports.PERSONAL);\n    if (codeHash) {\n        s.update(exports.hexToBytes(codeHash.replace(/^0x/, '')));\n    }\n    if (args && args.length) {\n        args.forEach(arg => (typeof arg === 'string' ? s.update(exports.hexToBytes(arg)) : s.update(arg)));\n    }\n    const digest = s.digest('hex');\n    return digest;\n};\n//# sourceMappingURL=index.js.map","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst blake2b_wasm_1 = __importDefault(require(\"blake2b-wasm\"));\nconst bech32_1 = __importDefault(require(\"./bech32\"));\nconst blake160_1 = __importDefault(require(\"./blake160\"));\nmodule.exports = {\n    blake2b: blake2b_wasm_1.default,\n    blake160: blake160_1.default,\n    bech32: bech32_1.default,\n};\nexports.default = {\n    blake2b: blake2b_wasm_1.default,\n    blake160: blake160_1.default,\n    bech32: bech32_1.default,\n};\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst LIMIT = 90;\nconst SEPARATOR = '1';\nconst alphabetMap = new Map();\nfor (let i = 0; i < ALPHABET.length; i++) {\n    const char = ALPHABET.charAt(i);\n    if (alphabetMap.get(char) !== undefined) {\n        throw new TypeError(`${char} is ambiguous`);\n    }\n    alphabetMap.set(char, i);\n}\nconst polymodStep = (values) => {\n    const b = values >> 25;\n    return (((values & 0x1ffffff) << 5) ^\n        (-((b >> 0) & 1) & 0x3b6a57b2) ^\n        (-((b >> 1) & 1) & 0x26508e6d) ^\n        (-((b >> 2) & 1) & 0x1ea119fa) ^\n        (-((b >> 3) & 1) & 0x3d4233dd) ^\n        (-((b >> 4) & 1) & 0x2a1462b3));\n};\nconst prefixChecksum = (prefix) => {\n    let checksum = 1;\n    for (let i = 0; i < prefix.length; ++i) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        checksum = polymodStep(checksum) ^ (c >> 5);\n    }\n    checksum = polymodStep(checksum);\n    for (let i = 0; i < prefix.length; ++i) {\n        const v = prefix.charCodeAt(i);\n        checksum = polymodStep(checksum) ^ (v & 0x1f);\n    }\n    return checksum;\n};\nexports.encode = (prefix, words, limit = LIMIT) => {\n    const formattedPrefix = prefix.toLowerCase();\n    if (formattedPrefix.length + 7 + words.length > limit)\n        throw new TypeError('Exceeds length limit');\n    let checksum = prefixChecksum(formattedPrefix);\n    let result = `${formattedPrefix}${SEPARATOR}`;\n    for (let i = 0; i < words.length; ++i) {\n        const x = words[i];\n        if (x >> 5 !== 0)\n            throw new Error('Non 5-bit word');\n        checksum = polymodStep(checksum) ^ x;\n        result += ALPHABET.charAt(x);\n    }\n    for (let i = 0; i < 6; ++i) {\n        checksum = polymodStep(checksum);\n    }\n    checksum ^= 1;\n    for (let i = 0; i < 6; ++i) {\n        const v = (checksum >> ((5 - i) * 5)) & 0x1f;\n        result += ALPHABET.charAt(v);\n    }\n    return result;\n};\nexports.decode = (encoded, limit = LIMIT) => {\n    const lowered = encoded.toLowerCase();\n    const uppered = encoded.toUpperCase();\n    if (encoded !== lowered && encoded !== uppered)\n        throw new Error(`Mixed-case string ${encoded}`);\n    const str = lowered;\n    if (str.length < 8)\n        throw new TypeError(`${str} too short`);\n    if (str.length > limit)\n        throw new TypeError('Exceeds length limit');\n    const split = str.lastIndexOf(SEPARATOR);\n    if (split === -1)\n        throw new Error(`No separator character for ${str}`);\n    if (split === 0)\n        throw new Error(`Missing prefix for ${str}`);\n    const prefix = str.slice(0, split);\n    const wordChars = str.slice(split + 1);\n    if (wordChars.length < 6)\n        throw new Error('Data too short');\n    let checksum = prefixChecksum(prefix);\n    const words = [];\n    wordChars.split('').forEach((_, i) => {\n        const c = wordChars.charAt(i);\n        const v = alphabetMap.get(c);\n        if (v === undefined)\n            throw new Error(`Unknown character ${c}`);\n        checksum = polymodStep(checksum) ^ v;\n        if (i + 6 < wordChars.length) {\n            words.push(v);\n        }\n    });\n    if (checksum !== 1)\n        throw new Error(`Invalid checksum for ${str}`);\n    return {\n        prefix,\n        words,\n    };\n};\nconst convert = (data, inBits, outBits, pad) => {\n    let value = 0;\n    let bits = 0;\n    const maxV = (1 << outBits) - 1;\n    const result = [];\n    for (let i = 0; i < data.length; ++i) {\n        value = (value << inBits) | data[i];\n        bits += inBits;\n        while (bits >= outBits) {\n            bits -= outBits;\n            result.push((value >> bits) & maxV);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            result.push((value << (outBits - bits)) & maxV);\n        }\n    }\n    else {\n        if (bits >= inBits)\n            throw new Error('Excess padding');\n        if ((value << (outBits - bits)) & maxV)\n            throw new Error('Non-zero padding');\n    }\n    return new Uint8Array(result);\n};\nexports.toWords = (bytes) => convert(bytes, 8, 5, true);\nexports.fromWords = (words) => convert(words, 5, 8, false);\nexports.default = {\n    decode: exports.decode,\n    encode: exports.encode,\n    toWords: exports.toWords,\n    fromWords: exports.fromWords,\n};\n//# sourceMappingURL=bech32.js.map","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst blake2b_wasm_1 = __importDefault(require(\"blake2b-wasm\"));\nconst index_1 = require(\"../index\");\nexports.blake160 = (data, encode = 'binary') => {\n    const formattedData = typeof data === 'string' ? index_1.hexToBytes(data) : data;\n    const s = blake2b_wasm_1.default(32, null, null, index_1.PERSONAL);\n    s.update(formattedData);\n    return s.digest(encode).slice(0, encode === 'binary' ? 20 : 40);\n};\nexports.default = exports.blake160;\n//# sourceMappingURL=blake160.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst __1 = require(\"..\");\nvar AddressPrefix;\n(function (AddressPrefix) {\n    AddressPrefix[\"Mainnet\"] = \"ckb\";\n    AddressPrefix[\"Testnet\"] = \"ckt\";\n})(AddressPrefix = exports.AddressPrefix || (exports.AddressPrefix = {}));\nvar AddressType;\n(function (AddressType) {\n    AddressType[\"BinHash\"] = \"0x00\";\n    AddressType[\"BinIdx\"] = \"0x01\";\n})(AddressType = exports.AddressType || (exports.AddressType = {}));\nvar AddressBinIdx;\n(function (AddressBinIdx) {\n    AddressBinIdx[\"P2PH\"] = \"P2PH\";\n})(AddressBinIdx = exports.AddressBinIdx || (exports.AddressBinIdx = {}));\nexports.defaultAddressOptions = {\n    prefix: AddressPrefix.Testnet,\n    type: AddressType.BinIdx,\n    binIdx: AddressBinIdx.P2PH,\n};\nexports.toAddressPayload = (identifier, type = AddressType.BinIdx, params = AddressBinIdx.P2PH) => {\n    if (typeof identifier === 'string') {\n        return new Uint8Array([...__1.hexToBytes(type), ...__1.utf8ToBytes(params), ...__1.hexToBytes(identifier)]);\n    }\n    return new Uint8Array([...__1.hexToBytes(type), ...__1.utf8ToBytes(params), ...identifier]);\n};\nexports.toAddressIdentifier = exports.toAddressPayload;\nexports.bech32Address = (data, { prefix = AddressPrefix.Testnet, type = AddressType.BinIdx, binIdx = AddressBinIdx.P2PH, } = exports.defaultAddressOptions) => __1.bech32.encode(prefix, __1.bech32.toWords(exports.toAddressIdentifier(data, type, binIdx)));\nexports.pubkeyToAddress = (pubkey, { prefix = AddressPrefix.Testnet, type = AddressType.BinIdx, binIdx = AddressBinIdx.P2PH, } = exports.defaultAddressOptions) => {\n    const identifier = __1.blake160(pubkey);\n    return exports.bech32Address(identifier, {\n        prefix,\n        type,\n        binIdx,\n    });\n};\nexports.parseAddress = (address, prefix = AddressPrefix.Testnet, encode = 'binary') => {\n    const decoded = __1.bech32.decode(address);\n    if (decoded.prefix !== prefix) {\n        throw new Error('Prefix not matched');\n    }\n    const data = __1.bech32.fromWords(new Uint8Array(decoded.words));\n    return encode === 'binary' ? data : __1.bytesToHex(data);\n};\n//# sourceMappingURL=index.js.map"]}