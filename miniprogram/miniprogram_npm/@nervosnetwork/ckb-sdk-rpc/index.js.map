{"version":3,"sources":["index.js","defaultRPC.js","paramsFormatter.js","resultFormatter.js","method.js","enum.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AIZA,AFMA,ACHA;AFOA,ADGA,AIZA,AFMA,ACHA;AFOA,ADGA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,AIZA,ALeA,AIZA,AFMA,ACHA;AFOA,ADGA,AIZA,AFMA,ACHA;AFOA,ADGA,AIZA,AFMA,ACHA;AFOA,ADGA,AIZA,AFMA,ACHA;AFOA,ADGA,AIZA,AFMA,ACHA;AFOA,ADGA,AIZA,AFMA,ACHA;AFOA,ADGA,AIZA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst defaultRPC_1 = __importDefault(require(\"./defaultRPC\"));\nconst method_1 = __importDefault(require(\"./method\"));\nconst paramsFormatter_1 = __importDefault(require(\"./paramsFormatter\"));\nconst resultFormatter_1 = __importDefault(require(\"./resultFormatter\"));\nclass CKBRPC extends defaultRPC_1.default {\n    constructor(url) {\n        super();\n        this.node = {\n            url: '',\n        };\n        this.methods = [];\n        this.paramsFormatter = paramsFormatter_1.default;\n        this.resultFormatter = resultFormatter_1.default;\n        this.setDebugLevel = (level) => {\n            method_1.default.debugLevel = level;\n        };\n        this.addMethod = (options) => {\n            const method = new method_1.default(this.node, options);\n            this.methods.push(method);\n            Object.defineProperty(this, options.name, {\n                value: method.call,\n                enumerable: true,\n            });\n        };\n        this.setNode({\n            url,\n        });\n        this.defaultMethods.map(this.addMethod);\n    }\n    setNode(node) {\n        Object.assign(this.node, node);\n        return this.node;\n    }\n}\nexports.default = CKBRPC;\n//# sourceMappingURL=index.js.map","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst paramsFormatter_1 = __importDefault(require(\"./paramsFormatter\"));\nconst resultFormatter_1 = __importDefault(require(\"./resultFormatter\"));\nconst defaultRPC = [\n    {\n        name: 'getBlockByNumber',\n        method: 'get_block_by_number',\n        paramsFormatters: [paramsFormatter_1.default.toNumber],\n        resultFormatters: resultFormatter_1.default.toBlock,\n    },\n    {\n        name: 'getBlock',\n        method: 'get_block',\n        paramsFormatters: [paramsFormatter_1.default.toHash],\n        resultFormatters: resultFormatter_1.default.toBlock,\n    },\n    {\n        name: 'getTransaction',\n        method: 'get_transaction',\n        paramsFormatters: [paramsFormatter_1.default.toHash, paramsFormatter_1.default.toNumber, paramsFormatter_1.default.toNumber],\n        resultFormatters: resultFormatter_1.default.toTransactionWithStatus,\n    },\n    {\n        name: 'getBlockHash',\n        method: 'get_block_hash',\n        paramsFormatters: [paramsFormatter_1.default.toNumber],\n    },\n    {\n        name: 'getTipHeader',\n        method: 'get_tip_header',\n        paramsFormatters: [],\n        resultFormatters: resultFormatter_1.default.toHeader,\n    },\n    {\n        name: 'getCellsByLockHash',\n        method: 'get_cells_by_lock_hash',\n        paramsFormatters: [paramsFormatter_1.default.toHash, paramsFormatter_1.default.toNumber, paramsFormatter_1.default.toNumber],\n        resultFormatters: resultFormatter_1.default.toCellsIncludingOutPoint,\n    },\n    {\n        name: 'getLiveCell',\n        method: 'get_live_cell',\n        paramsFormatters: [paramsFormatter_1.default.toOutPoint],\n        resultFormatters: resultFormatter_1.default.toCellWithStatus,\n    },\n    {\n        name: 'getTipBlockNumber',\n        method: 'get_tip_block_number',\n        paramsFormatters: [],\n        resultFormatters: resultFormatter_1.default.toNumber,\n    },\n    {\n        name: 'getBlockchainInfo',\n        method: 'get_blockchain_info',\n        paramsFormatters: [],\n        resultFormatters: resultFormatter_1.default.toBlockchainInfo,\n    },\n    {\n        name: 'sendTransaction',\n        method: 'send_transaction',\n        paramsFormatters: [paramsFormatter_1.default.toRawTransaction],\n        resultFormatters: resultFormatter_1.default.toHash,\n    },\n    {\n        name: 'localNodeInfo',\n        method: 'local_node_info',\n        paramsFormatters: [],\n        resultFormatters: resultFormatter_1.default.toNodeInfo,\n    },\n    {\n        name: 'txPoolInfo',\n        method: 'tx_pool_info',\n        paramsFormatters: [],\n        resultFormatters: resultFormatter_1.default.toTxPoolInfo,\n    },\n    {\n        name: 'getPeers',\n        method: 'get_peers',\n        paramsFormatters: [],\n        resultFormatters: resultFormatter_1.default.toPeers,\n    },\n    {\n        name: 'getPeersState',\n        method: 'get_peers_state',\n        paramsFormatters: [],\n        resultFormatters: resultFormatter_1.default.toPeersState,\n    },\n    {\n        name: 'getCurrentEpoch',\n        method: 'get_current_epoch',\n        paramsFormatters: [],\n        resultFormatters: resultFormatter_1.default.toEpoch,\n    },\n    {\n        name: 'getEpochByNumber',\n        method: 'get_epoch_by_number',\n        paramsFormatters: [paramsFormatter_1.default.toNumber],\n        resultFormatters: resultFormatter_1.default.toEpoch,\n    },\n    {\n        name: 'dryRunTransaction',\n        method: 'dry_run_transaction',\n        paramsFormatters: [paramsFormatter_1.default.toRawTransaction],\n    },\n    {\n        name: 'deindexLockHash',\n        method: 'deindex_lock_hash',\n        paramsFormatters: [paramsFormatter_1.default.toHash],\n    },\n    {\n        name: 'getLiveCellsByLockHash',\n        method: 'get_live_cells_by_lock_hash',\n        paramsFormatters: [paramsFormatter_1.default.toHash, paramsFormatter_1.default.toPageNumber, paramsFormatter_1.default.toPageSize, paramsFormatter_1.default.toReverseOrder],\n        resultFormatters: resultFormatter_1.default.toLiveCellsByLockHash,\n    },\n    {\n        name: 'getLockHashIndexStates',\n        method: 'get_lock_hash_index_states',\n        paramsFormatters: [],\n        resultFormatters: resultFormatter_1.default.toLockHashIndexStates,\n    },\n    {\n        name: 'getTransactionsByLockHash',\n        method: 'get_transactions_by_lock_hash',\n        paramsFormatters: [paramsFormatter_1.default.toHash, paramsFormatter_1.default.toPageNumber, paramsFormatter_1.default.toPageSize, paramsFormatter_1.default.toReverseOrder],\n        resultFormatters: resultFormatter_1.default.toTransactionsByLockHash,\n    },\n    {\n        name: 'indexLockHash',\n        method: 'index_lock_hash',\n        paramsFormatters: [paramsFormatter_1.default.toHash],\n        resultFormatters: resultFormatter_1.default.toLockHashIndexState,\n    },\n];\nclass DefaultRPC {\n    constructor() {\n        this.defaultMethods = defaultRPC;\n    }\n}\nexports.DefaultRPC = DefaultRPC;\nexports.default = DefaultRPC;\n//# sourceMappingURL=defaultRPC.js.map","\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst formatter = {\n    toScript: (_a) => {\n        var { codeHash: code_hash } = _a, rest = __rest(_a, [\"codeHash\"]);\n        return (Object.assign({ code_hash }, rest));\n    },\n    toHash: (hash) => (hash.startsWith('0x') ? hash : `0x${hash}`),\n    toCellOutPoint: (_a) => {\n        var { txHash: tx_hash } = _a, rest = __rest(_a, [\"txHash\"]);\n        return (Object.assign({ tx_hash }, rest));\n    },\n    toOutPoint: (_a) => {\n        var { cell = null, blockHash: block_hash = null } = _a, rest = __rest(_a, [\"cell\", \"blockHash\"]);\n        return (Object.assign({ cell: cell ? formatter.toCellOutPoint(cell) : cell, block_hash }, rest));\n    },\n    toNumber: (number) => number.toString(),\n    toInput: (_a) => {\n        var { previousOutput } = _a, rest = __rest(_a, [\"previousOutput\"]);\n        return (Object.assign({ previous_output: formatter.toOutPoint(previousOutput) }, rest));\n    },\n    toOutput: (_a) => {\n        var { lock, type } = _a, rest = __rest(_a, [\"lock\", \"type\"]);\n        return (Object.assign({ lock: formatter.toScript(lock), type: type ? formatter.toScript(type) : null }, rest));\n    },\n    toRawTransaction: (_a) => {\n        var { version, deps, inputs, outputs } = _a, rest = __rest(_a, [\"version\", \"deps\", \"inputs\", \"outputs\"]);\n        const formattedInputs = inputs.map(input => formatter.toInput(input));\n        const formattedOutputs = outputs.map(output => formatter.toOutput(output));\n        const formattedDeps = deps.map(dep => formatter.toOutPoint(dep));\n        const tx = Object.assign({ version, deps: formattedDeps, inputs: formattedInputs, outputs: formattedOutputs }, rest);\n        return tx;\n    },\n    toPageNumber: (pageNo = '1') => pageNo.toString(),\n    toPageSize: (pageSize = 50) => {\n        const size = +pageSize || 50;\n        if (size > 50)\n            throw new Error('Page size is up to 50');\n        if (size < 0)\n            throw new Error('Page size is expected to be positive');\n        return `${size}`;\n    },\n    toReverseOrder: (reverse = false) => !!reverse,\n};\nexports.default = formatter;\n//# sourceMappingURL=paramsFormatter.js.map","\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst formatter = {\n    toNumber: (number) => number.toString(),\n    toHash: (hash) => hash,\n    toHeader: (header) => {\n        if (!header)\n            return header;\n        const { transactions_root, proposals_hash, witnesses_root, uncles_hash, uncles_count, parent_hash } = header, rest = __rest(header, [\"transactions_root\", \"proposals_hash\", \"witnesses_root\", \"uncles_hash\", \"uncles_count\", \"parent_hash\"]);\n        return Object.assign({ parentHash: parent_hash, transactionsRoot: transactions_root, proposalsHash: proposals_hash, witnessesRoot: witnesses_root, unclesHash: uncles_hash, unclesCount: uncles_count }, rest);\n    },\n    toScript: (script) => {\n        if (!script)\n            return script;\n        const { code_hash: codeHash } = script, rest = __rest(script, [\"code_hash\"]);\n        return Object.assign({ codeHash }, rest);\n    },\n    toInput: (input) => {\n        if (!input)\n            return input;\n        const { previous_output: previousOutput } = input, rest = __rest(input, [\"previous_output\"]);\n        return Object.assign({ previousOutput: formatter.toOutPoint(previousOutput) }, rest);\n    },\n    toOutput: (output) => {\n        if (!output)\n            return output;\n        const { lock, type } = output, rest = __rest(output, [\"lock\", \"type\"]);\n        return Object.assign({ lock: formatter.toScript(lock), type: type ? formatter.toScript(type) : type }, rest);\n    },\n    toCellOutPoint: (cellOutPoint) => {\n        if (!cellOutPoint)\n            return cellOutPoint;\n        const { tx_hash: txHash } = cellOutPoint, rest = __rest(cellOutPoint, [\"tx_hash\"]);\n        return Object.assign({ txHash }, rest);\n    },\n    toOutPoint: (outPoint) => {\n        if (!outPoint)\n            return outPoint;\n        const { block_hash: blockHash = null, cell = null } = outPoint;\n        return {\n            blockHash,\n            cell: cell ? formatter.toCellOutPoint(cell) : cell,\n        };\n    },\n    toTransaction: (tx) => {\n        if (!tx)\n            return tx;\n        const { deps = [], inputs = [], outputs = [] } = tx, rest = __rest(tx, [\"deps\", \"inputs\", \"outputs\"]);\n        return Object.assign({ deps: deps.map(formatter.toOutPoint), inputs: inputs.map(formatter.toInput), outputs: outputs.map(formatter.toOutput) }, rest);\n    },\n    toUncleBlock: (uncleBlock) => {\n        if (!uncleBlock)\n            return uncleBlock;\n        const { header } = uncleBlock, rest = __rest(uncleBlock, [\"header\"]);\n        return Object.assign({ header: formatter.toHeader(header) }, rest);\n    },\n    toBlock: (block) => {\n        if (!block)\n            return block;\n        const { header, uncles = [], transactions = [] } = block, rest = __rest(block, [\"header\", \"uncles\", \"transactions\"]);\n        return Object.assign({ header: formatter.toHeader(header), uncles: uncles.map(formatter.toUncleBlock), transactions: transactions.map(formatter.toTransaction) }, rest);\n    },\n    toAlertMessage: (alertMessage) => {\n        if (!alertMessage)\n            return alertMessage;\n        const { notice_until: noticeUntil } = alertMessage, rest = __rest(alertMessage, [\"notice_until\"]);\n        return Object.assign({ noticeUntil }, rest);\n    },\n    toBlockchainInfo: (info) => {\n        if (!info)\n            return info;\n        const { is_initial_block_download: isInitialBlockDownload, median_time: medianTime, alerts } = info, rest = __rest(info, [\"is_initial_block_download\", \"median_time\", \"alerts\"]);\n        return Object.assign({ isInitialBlockDownload,\n            medianTime, alerts: alerts.map(formatter.toAlertMessage) }, rest);\n    },\n    toNodeInfo: (info) => {\n        if (!info)\n            return info;\n        const { node_id: nodeId, is_outbound: isOutbound } = info, rest = __rest(info, [\"node_id\", \"is_outbound\"]);\n        return Object.assign({ nodeId,\n            isOutbound }, rest);\n    },\n    toTxPoolInfo: (info) => {\n        if (!info)\n            return info;\n        const { last_txs_updated_at: lastTxsUpdatedAt, total_tx_cycles: totalTxCycles, total_tx_size: totalTxSize } = info, rest = __rest(info, [\"last_txs_updated_at\", \"total_tx_cycles\", \"total_tx_size\"]);\n        return Object.assign({ lastTxsUpdatedAt,\n            totalTxCycles,\n            totalTxSize }, rest);\n    },\n    toPeers: (nodes = []) => nodes.map(formatter.toNodeInfo),\n    toPeersState: (state) => {\n        if (!state)\n            return state;\n        const { last_updated: lastUpdated, blocks_in_flight: blocksInFlight } = state, rest = __rest(state, [\"last_updated\", \"blocks_in_flight\"]);\n        return Object.assign({ lastUpdated,\n            blocksInFlight }, rest);\n    },\n    toCell: (cell) => {\n        if (!cell)\n            return cell;\n        const { lock, type } = cell, rest = __rest(cell, [\"lock\", \"type\"]);\n        return Object.assign({ lock: formatter.toScript(lock), type: type ? formatter.toScript(type) : null }, rest);\n    },\n    toCellWithStatus: (cellWithStatus) => {\n        if (!cellWithStatus)\n            return cellWithStatus;\n        const { cell } = cellWithStatus, rest = __rest(cellWithStatus, [\"cell\"]);\n        return Object.assign({ cell: formatter.toCell(cell) }, rest);\n    },\n    toCells: (cells = []) => cells.map(formatter.toCell),\n    toCellIncludingOutPoint: (cell) => {\n        if (!cell)\n            return cell;\n        const { lock, out_point } = cell, rest = __rest(cell, [\"lock\", \"out_point\"]);\n        return Object.assign({ lock: formatter.toScript(lock), outPoint: formatter.toOutPoint(out_point) }, rest);\n    },\n    toCellsIncludingOutPoint: (cells = []) => cells.map(formatter.toCellIncludingOutPoint),\n    toTransactionWithStatus: (txWithStatus) => {\n        if (!txWithStatus)\n            return txWithStatus;\n        const { transaction, tx_status: { block_hash: blockHash, status } } = txWithStatus, rest = __rest(txWithStatus, [\"transaction\", \"tx_status\"]);\n        return Object.assign({ transaction: formatter.toTransaction(transaction), txStatus: {\n                blockHash,\n                status,\n            } }, rest);\n    },\n    toEpoch: (epoch) => {\n        if (!epoch)\n            return epoch;\n        const { epoch_reward: epochReward, start_number: startNumber } = epoch, rest = __rest(epoch, [\"epoch_reward\", \"start_number\"]);\n        return Object.assign({ epochReward,\n            startNumber }, rest);\n    },\n    toTransactionPoint: (transactionPoint) => {\n        if (!transactionPoint)\n            return transactionPoint;\n        const { block_number: blockNumber, tx_hash: txHash } = transactionPoint, rest = __rest(transactionPoint, [\"block_number\", \"tx_hash\"]);\n        return Object.assign({ blockNumber,\n            txHash }, rest);\n    },\n    toTransactionsByLockHash: (transactions) => {\n        if (!transactions)\n            return transactions;\n        return transactions.map(tx => ({\n            consumedBy: tx.consumed_by ? formatter.toTransactionPoint(tx.consumed_by) : tx.consumed_by,\n            createdBy: formatter.toTransactionPoint(tx.created_by),\n        }));\n    },\n    toLiveCellsByLockHash: (cells) => {\n        if (!cells)\n            return cells;\n        return cells.map(cell => ({\n            cellOutput: formatter.toCell(cell.cell_output),\n            createdBy: formatter.toTransactionPoint(cell.created_by),\n        }));\n    },\n    toLockHashIndexState: (index) => {\n        if (!index)\n            return index;\n        const { block_hash: blockHash, block_number: blockNumber, lock_hash: lockHash } = index, rest = __rest(index, [\"block_hash\", \"block_number\", \"lock_hash\"]);\n        return Object.assign({ blockHash,\n            blockNumber,\n            lockHash }, rest);\n    },\n    toLockHashIndexStates: (states) => {\n        if (!states)\n            return states;\n        return states.map(formatter.toLockHashIndexState);\n    },\n};\nexports.default = formatter;\n//# sourceMappingURL=resultFormatter.js.map","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst axios_1 = __importDefault(require(\"axios\"));\nconst enum_1 = require(\"./enum\");\nclass Method {\n    constructor(node, options) {\n        this.options = {\n            name: '',\n            method: '',\n            paramsFormatters: [],\n            resultFormatters: undefined,\n        };\n        this.call = (...params) => {\n            const data = params.map((p, i) => (this.options.paramsFormatters[i] && this.options.paramsFormatters[i](p)) || p);\n            const id = Math.round(Math.random() * 10000);\n            const payload = {\n                id,\n                method: this.options.method,\n                params: data,\n                jsonrpc: '2.0',\n            };\n            return axios_1.default({\n                method: 'POST',\n                headers: {\n                    'content-type': 'application/json',\n                },\n                data: payload,\n                url: this.node.url,\n            }).then(res => {\n                if (res.data.id !== id) {\n                    throw new Error('JSONRPC id not match');\n                }\n                if (Method.debugLevel === enum_1.DebugLevel.On) {\n                    console.group();\n                    console.group();\n                    console.info(enum_1.LogColor.Cyan, `\\n----- ${this.options.name} request -----`, enum_1.LogColor.Reset);\n                    console.info(JSON.stringify(payload, null, 2));\n                    console.groupEnd();\n                    console.group();\n                    console.info(enum_1.LogColor.Cyan, `----- ${this.options.name} response -----`, enum_1.LogColor.Reset);\n                    console.info(JSON.stringify(res.data, null, 2));\n                    console.groupEnd();\n                    console.groupEnd();\n                }\n                if (res.data.error) {\n                    throw new Error(JSON.stringify(res.data.error));\n                }\n                return this.options.resultFormatters ? this.options.resultFormatters(res.data.result) : res.data.result;\n            });\n        };\n        this.node = node;\n        this.options = options;\n    }\n}\nMethod.debugLevel = enum_1.DebugLevel.Off;\nexports.default = Method;\n//# sourceMappingURL=method.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DebugLevel;\n(function (DebugLevel) {\n    DebugLevel[DebugLevel[\"Off\"] = 0] = \"Off\";\n    DebugLevel[DebugLevel[\"On\"] = 1] = \"On\";\n})(DebugLevel = exports.DebugLevel || (exports.DebugLevel = {}));\nvar LogColor;\n(function (LogColor) {\n    LogColor[\"Reset\"] = \"\\u001B[0m\";\n    LogColor[\"Black\"] = \"\\u001B[30m\";\n    LogColor[\"Red\"] = \"\\u001B[31m\";\n    LogColor[\"Green\"] = \"\\u001B[32m\";\n    LogColor[\"Yellow\"] = \"\\u001B[33m\";\n    LogColor[\"Blue\"] = \"\\u001B[34m\";\n    LogColor[\"Magenta\"] = \"\\u001B[35m\";\n    LogColor[\"Cyan\"] = \"\\u001B[36m\";\n    LogColor[\"White\"] = \"\\u001B[37m\";\n})(LogColor = exports.LogColor || (exports.LogColor = {}));\n//# sourceMappingURL=enum.js.map"]}